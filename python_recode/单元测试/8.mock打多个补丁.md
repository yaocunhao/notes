- 在一次调用之中打多个补丁

- 一次调用，给对象的多个函数进行mock

  ```python
  import unittest
  from unittest.mock import patch
  
  
  class MyClass:
  
    def method1(self):
      return "original method1"
  
    def method2(self):
      return "original method2"
  
  
  class MulTest(unittest.TestCase):
  	
    # 一次性mock 多个数据
    @patch.multiple(MyClass,
                    method1=lambda x: "mocked method1",
                    method2=lambda x: "mocked method2")
    def test_mul(sel):
      obj = MyClass()
      print(obj.method1())
      print(obj.method2())
  
  
  if __name__ == '__main__':
    unittest.main()
    
    
    
    # ----------------- 第二种写法 --------------
    
  class MyClass:
  
    def method1(self):
      return "original method1"
  
    def method2(self):
      return "original method2"
  
  # 接收一个参数是因为 ‘MyClass’ 是接受一个参数的
  def mock_func(self):
    return '123'
  
  
  class MulTest(unittest.TestCase):
  
    @patch.multiple(MyClass, method1=mock_func, method2=mock_func)
    def test_mul(sel):
      obj = MyClass()
      print(obj.method1())
      print(obj.method2())
  
  
  if __name__ == '__main__':
    unittest.main()
  ```

- 使用系统默认mock 值

  ```python
  import unittest
  from unittest.mock import patch, DEFAULT, MagicMock
  
  thing = 'ccc'
  other = 'ccc'
  
  
  class MulTest(unittest.TestCase):
  
    @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)
    def test_function(self, thing, other):
      assert isinstance(thing, MagicMock)
      assert isinstance(other, MagicMock)
  
  
  if __name__ == '__main__':
    unittest.main()
  ```

  