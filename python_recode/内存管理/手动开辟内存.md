- [python开辟内存](https://blog.51cto.com/u_16175477/6897570?articleABtest=0)

  ```python
  	# 开辟25GB的内存出来
    GB = 25 * 1024 * 1024 * 1024
    size = GB // 4
    my_type = ctypes.c_int * size
    my_memory = ctypes.create_string_buffer(ctypes.sizeof(my_type))
  ```

- [python调用C 语言库函数](https://www.bilibili.com/read/cv23287285/)

  ```python
  libc = ctypes.CDLL("libc.so.6") # 加载C语言库
  # 释放内存
  libc.malloc_trim(0)
  ```

  

- [python内存管理机制](https://blog.csdn.net/zy010101/article/details/122898332)
  - 缓存管理：实际上，并不是当引用计数为0的时候，就立即回收内存。因为这样将会导致python频繁的malloc和free，导致程序执行效率下降。引用计数器为0时，不会真正销毁对象，而是将他放到一个名为 free_list 的链表中，之后会再创建对象时不会在重新开辟内存，而是在free_list中将之前的对象来并重置内部的值来使用
  - [内存管理官档](https://docs.python.org/zh-cn/3/c-api/memory.html)

- [使用 pop() 方法，只会缩减可变对象中的元素，但并不会释放已申请的内存空间](https://blog.csdn.net/weixin_30905039/article/details/112670370) 

  - 不全对，list 之中存储的是地址，所以不会释放也就占用 8/4 字节

- [分代回收文档](https://www.zhihu.com/question/34895986/answer/2665728706?utm_id=0)

  - 垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动[垃圾回收](https://www.zhihu.com/search?q=垃圾回收&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2665728706})。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。我们可以通过gc模块的get_threshold()方法，查看该阈值:

    ```python3
    import gc
    print(gc.get_threshold())
    
    # 来自 “源码角度分析” 链接
    0代： 0代中对象个数达到700个，扫描一次。
    1代： 0代扫描10次，则1代扫描1次。
    2代： 1代扫描10次，则2代扫描1次。
    ```

- [源码角度分析](https://blog.csdn.net/m0_51691302/article/details/123117569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169938298716800227480685%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169938298716800227480685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-123117569-null-null.142^v96^pc_search_result_base1&utm_term=python%20%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%A7%A6%E5%8F%91%E7%9A%84%E6%97%B6%E6%9C%BA&spm=1018.2226.3001.4187)