# 一、对参数类型进行验证

# 二、验证和默认值

- 如果使用了默认值，将不会触发验证器
- @field_validator验证器和Annotated验证器。你可以使用Field(validate_defaults=True)强制它们运行验证器

## 2.1 使用了默认值和没有使用默认值

- 没有使用默认值的会运行校验器

```python
def test1():
  class Model(BaseModel):
     # 使用了默认值，校验器不会 运行， `Field....` 强制运行校验器
      x: str = 'abc'
      y:str

      # 对字段x,y 进行校验， 字符串重复
      @field_validator('x', 'y')
      @classmethod
      def double(cls, v: str) -> str:
          return v * 2

	
  # 根据结果可知， x使用了默认值，y没有，因此y输出时是double的
  print(Model(y="123")) # x='abc' y='123123'
```

## 2.2 使用字段强制执行

- y字段是强制执行的，因此不论有没有传值都是double输出

```python
def test2():
  class Model(BaseModel):
      x: str = 'abc'
      y: Annotated[str, Field(validate_default=True)] = 'xyz'

      # 对字段x,y 进行校验， 字符串重复
      @field_validator('x', 'y')
      @classmethod
      def double(cls, v: str) -> str:
          return v * 2


  print(Model()) # x='abc' y='xyzxyz'
  print(Model(x='456')) # x='456456' y='xyzxyz'
```



# 三、字段校验器

- `@field_validator` 进行字段的校验

  - 可以选择多个字段，或者使用  `*` 来校验所有字段
  - `FieldValidationInfo`
    - field_name： 输出当前验证的字段名称
    - info.data：输出已验证的字段数据

  ```python
  from pydantic import (
      BaseModel,
      FieldValidationInfo,
      ValidationError,
      field_validator,
  )
  
  
  class UserModel(BaseModel):
      id: int
      name: str
  
      # 校验规则：name中必须存在空格
      @field_validator('name')
      @classmethod
      def name_must_contain_space(cls, v: str) -> str:
          if ' ' not in v:
              raise ValueError('must contain a space')
          return v.title()
  
      # 校验规则：
        # 1、如果字段是字符串，去除空格 string 
        # 至少有一个字符,并且是否有字母和数字组成
      
      # 特性：
          # 1、可以选择多个字段，或者使用 '*' 来校验所有字段
          # info.field_name:  输出字段名字
      
      # 这里两个字段，会调用两次，只是共用一套验证逻辑
      # info.field_name： 输出当前验证的字段名称
      # info.data: 输出已验证的字段数据
      @field_validator('id', 'name')
      @classmethod
      def check_alphanumeric(cls, v: str, info: FieldValidationInfo) -> str:
          print("_________________",info.field_name, info.data)
          # _________________ id {}
          # _________________ name {'id': 1}
          if isinstance(v, str):
              # info.field_name is the name of the field being validated
              is_alphanumeric = v.replace(' ', '').isalnum()
              assert is_alphanumeric, f'{info.field_name} must be alphanumeric'
          return v
  
  
  # print(UserModel(id=1, name='John Doe'))
  #> id=1 name='John Doe'
  
  
  try:
      UserModel(id="1", name='samuel 22') # id 自动转换成int
  except ValidationError as e:
      print(e)
      """
      1 validation error for UserModel
      name
        Value error, must contain a space [type=value_error, input_value='samuel', input_type=str]
      """
  
  # try:
  #     UserModel(id='abc', name='John Doe') # 这里的string 无法自动进行转换
  # except ValidationError as e:
  #     print(e)
  #     """
  #     1 validation error for UserModel
  #     id
  #       Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='abc', input_type=str]
  #     """
  
  # try:
  #     UserModel(id=1, name='John Doe!') # name 不是纯的字母和数字
  # except ValidationError as e:
  #     print(e)
  #     """
  #     1 validation error for UserModel
  #     name
  #       Assertion failed, name must be alphanumeric 
  #     assert False [type=assertion_error, input_value='John Doe!', input_type=str]
  #     """
  ```

- 注意事项

  - `@classmethod` 在 `field_validator` 字段下面
  -  第二个参数是要验证的字段值;你可以随意命名它
  - 第三个参数，如果存在的话是 `pydantic.FieldValidationInfo` 的一个对象
    - field_name： 输出当前验证的字段名称
    - info.data：输出已验证的字段数据。<font color=yellow>验证的顺序为定义的顺序</font>
  - 验证器应该返回解析后的值，或者引发 `ValueError` 或者 `AssertionError`
  - 一个验证器，可以选择多个字段，或者使用  `*` 来校验所有字段



# 四、Modle 验证器

- <font color=yellow>对整体参数进行验证,用这个更合适</font>

- 第一个参数为cls， 第二个推荐类型为`Any`， 本质就是一个dict

- modle == after, 在对类初始化时，会调用

- modle ==after， 初始化完成之后才会进行调用

  ```python
  from typing import Any
  
  from pydantic import BaseModel, ValidationError, model_validator,ValidationInfo
  
  
  class UserModel(BaseModel):
      username: str
      password1: str
      password2: str
  
      # 校验规则： 如果是dict，card_number 不在其中
      @model_validator(mode='before')
      @classmethod
      def check_card_number_omitted(cls, data: Any, values:ValidationInfo) -> Any:
          print(values.config, values.context) # {'title': 'UserModel'} None
          if isinstance(data, dict):
              assert (
                  'card_number' not in data
              ), 'card_number should not be included'
          
          # modle=before, 即在赋值前进行处理
          data['password1'] = data['password2']
          return data
  
      # 校验规则：密码不相等，报错
      # 这里通过self 进行访问， 也就是当mode=after时，验证器将是最后运行的
      @model_validator(mode='after')
      def check_passwords_match(self) -> 'UserModel':
          pw1 = self.password1
          pw2 = self.password2
          if pw1 is not None and pw2 is not None and pw1 != pw2:
              raise ValueError('passwords do not match')
          return self
  
  
  
  
  # print(UserModel(username='scolvin', password1='zxcvbn', password2='zxcvbn'))
  # print("________________")
  
  try:
      UserModel(username='scolvin', password1='zxcvbn', password2='zxcvbn2')
  except ValidationError as e:
      print(e)
  
  # print("________________")
  # try:
  #     UserModel(
  #         username='scolvin',
  #         password1='zxcvbn',
  #         password2='zxcvbn',
  #         card_number='1234',
  #     )
  # except ValidationError as e:
  #     print(e)
  ```

  

# 五、特殊类型

## 5.1 InstanceOf

- 用于判断当前对象是否是类的实例

  ```python
  from typing import List
  
  from pydantic import BaseModel, InstanceOf, ValidationError
  
  
  class Fruit:
      def __repr__(self):
          return self.__class__.__name__
  
  
  class Banana(Fruit):
      ...
  
  
  class Apple(Fruit):
      ...
  
  
  class Basket(BaseModel):
      fruits: List[InstanceOf[Fruit]]
  
  print(Basket(fruits=[Banana(), Apple()]))
  # print(Basket(fruits=[Banana(), Apple(),123]))
  
  
  try:
      Basket(fruits=[Banana(), 'Apple'])
  except ValidationError as e:
      print(e)
      """
      1 validation error for Basket
      fruits.1
        Input should be an instance of Fruit [type=is_instance_of, input_value='Apple', input_type=str]
      """
  ```

## 5.2 [`SkipValidation`](https://docs.pydantic.dev/2.1/api/functional_validators/#pydantic.functional_validators.SkipValidation)

- 跳过对字段的验证

  ```python
  from typing import List
  
  from pydantic import BaseModel, SkipValidation
  
  
  class Model(BaseModel):
      names: List[SkipValidation[str]]
  
  
  # str, str
  m = Model(names=['foo', 'bar'])
  print(m)
  
  # str, int
  m = Model(names=['foo', 123])  
  print(m)
  
  # 前后传的类型不一致， 但是都通过了校验， 所以说这里是跳过验证器
  ```

  