# 一、 [为什么在ifmain下](https://blog.csdn.net/Chasing__Dreams/article/details/107447436?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166125132116781683963131%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166125132116781683963131&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-107447436-null-null.article_score_rank_blog&utm_term=%E5%AE%9A%E4%B9%89%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%97%B6%EF%BC%8C%E4%B8%8D%E5%86%99if%20__name__%20%3D%3D%20__main__%3A&spm=1018.2226.3001.4450)

- windows 下每个子进程是有独立内存的，所以每个子进程是通过分别导入所在的脚本模块来实现目标函数的运行的。对于这个机制，有以下两点需要特别注意
- 由于每个子进程是通过导入所在脚本的模块实现模块中函数的调用的，所以，**为了避免将创建子进程的语句也被导入**（因为这样就会造成无限循环创建子进程，这显然是不允许的，因此python禁止了在子进程中再创建子进程，否则会报错），创建子进程的语句必须在`if __name__ == '__main_':`语句之后定义，或者如果创建子进程的语句是定义在一个函数中的，那么这个函数调用必须在if __name__==’__main__’:语句之后，这是python多进程中的强制性语法规则
- linux 是fork创建子进程，并且子进程共享代码的，并且在创建语句之后运行，所以不存在这种问题，**因此也不需要在main之下运型**



# 二、和concurrent 的区别

- [新老的区别而已](https://blog.csdn.net/qq_33385691/article/details/81082447?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168641136716800186553082%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=168641136716800186553082&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-81082447-null-null.142^v88^control_2,239^v2^insert_chatgpt&utm_term=multiprocess%20%E5%92%8C%20concurrent%20%E7%9A%84%E5%8C%BA%E5%88%AB&spm=1018.2226.3001.4187)
  - concurrent  是基于multiprocess 进行封装的



# 三、常用多进程模块不能序列化问题

- [link](https://zhuanlan.zhihu.com/p/555481500)
  - multiprocess模块采用dill来序列化并传递数据，避免了multiprocessing模块采用pickle的限制。但是用multiprocess模块的话，在子进程中无法使用之前导入的模块。只有再重新导入一次，multiprocessing就没有这个问题，但是很多函数不能pickle
- [一些解决办法](https://stackoverflow.com/questions/8804830/python-multiprocessing-picklingerror-cant-pickle-type-function)
- [如何处理pybind11+](https://stackoverflow.com/questions/69797634/how-to-pickle-an-object-which-is-written-in-c-through-pybind11)