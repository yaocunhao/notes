



- **使用多进程时，一般使用多进程通信消息机制实现进程间通信，尽可能避免使用同步原语，例如锁**

# 一、共享队列

## 1.1  构造函数

- `class `multiprocessing.`Queue([maxsize])`	

  - maxsize：队列长度，默认是不限制队列长度的

  - 返回一个使用一个管道和少量锁和信号量实现的共享队列实例。当一个进程将一个对象放进队列中时，一个写入线程会启动并将对象从缓冲区写入管道中

  - 一旦超时，将抛出标准库 [`queue`](https://docs.python.org/zh-cn/3/library/queue.html#module-queue) 模块中常见的异常 [`queue.Empty`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Empty) 和 [`queue.Full`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Full)

  - 除了 [`task_done()`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue.task_done) 和 [`join()`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue.join) 之外，[`Queue`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue) 实现了标准库类 [`queue.Queue`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue) 中所有的方法

    ​	

## 1.2 API接口

### 1.2.1 实现`queue.Queue`的方法

- `qsize`()
  - 返回队列的大致长度。由于多线程或者多进程的上下文，这个数字是不可靠的
  - 这可能会在Unix平台上引起 [`NotImplementedError`](https://docs.python.org/zh-cn/3/library/exceptions.html#NotImplementedError) ，如 macOS ，因为其上没有实现 `sem_getvalue()` 
- `empty`()
  - 如果队列是空的，返回 `True` ，反之返回 `False` 。 由于多线程或多进程的环境，该状态是不可靠的
- `full`()
  - 如果队列是满的，返回 `True` ，反之返回 `False` 。 由于多线程或多进程的环境，该状态是不可靠的
- `put`(*obj*, *block*=True, timeout=None)
  -  obj 放入队列。如果可选参数 *block* 是 `True` (默认值) 而且 *timeout* 是 `None` (默认值), 将会阻塞当前进程，直到队列可以插入
  - 如果 *timeout* 是正数，将会在阻塞了最多 *timeout* 秒之后还是没有可用的缓冲槽时抛出 [`queue.Full`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Full) 异常
  - 反之 (*block* 是 `False` 时)，仅当队列有可用缓冲槽时才放入对象，否则抛出 [`queue.Full`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Full) 异常 (在这种情形下 *timeout* 参数会被忽略)
- `put_nowait`(*obj*)
  - 等价于 put(obj, False)

- get(block=True, timeout)
  - 从队列之中取出并且返回任务
  - 参数的含义和put一样
- `get_nowait`()
  - 等价于 get(block=False)

### 1.2.2 额外的方法

- **这些方法都是自动调用的，一般不会在应用代码之中出现**

- close()
  - 指示当前进程不会将更多数据放入该队列中,后台线程将在将所有缓冲数据刷新到管道后退出.当队列被垃圾收集时，**会自动调用这个函数**
- `join_thread`()
  - join后台线程。这只能在调用close()之后使用。它会阻塞，直到后台线程退出，确保缓冲区中的所有数据都被刷新到管道中
  - 默认情况下，如果不是一个队列创建者的进程试图退出，**它会尝试等待这个队列的后台线程(不必手动调用)**。这个进程可以使用 [`cancel_join_thread()`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue.cancel_join_thread) 让 [`join_thread()`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue.join_thread) 方法什么都不做直接跳过
- `cancel_join_thread`()
  - 防止 [`join_thread()`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue.join_thread) 方法阻塞当前进程。具体而言，这防止进程退出时自动等待后台线程退出。详见 [`join_thread()`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue.join_thread)
  - 这个方法更好的名字可能是 `allow_exit_without_flush()`。 这可能会导致已排入队列的数据丢失，几乎可以肯定你将不需要用到这个方法。 实际上它仅适用于当你需要当前进程立即退出而不必等待将已排入的队列更新到下层管道，并且你不担心丢失数据的时候

## 1.3 注意事项

- 将一个对象放入一个空队列后，可能**需要极小的延迟**，队列的方法 [`empty()`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue.empty) 才会返回 [`False`](https://docs.python.org/zh-cn/3/library/constants.html#False) 。而 [`get_nowait()`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue.get_nowait) 可以不抛出 [`queue.Empty`](https://docs.python.org/zh-cn/3/library/queue.html#queue.Empty) 直接返回
- 如果有多个进程同时将对象放入队列，那么在队列的另一端接受到的对象可能是无序的。但是由同一个进程放入的多个对象的顺序在另一端输出时总是一样的
- 如果一个进程在尝试使用 [`Queue`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue) 期间被 [`Process.terminate()`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Process.terminate) 或 [`os.kill()`](https://docs.python.org/zh-cn/3/library/os.html#os.kill) 调用终止了，那么队列中的数据很可能被破坏。 这可能导致其他进程在尝试使用该队列时发生异常
- 如果一个子进程将一些对象放进队列中 (并且它没有用 [`JoinableQueue.cancel_join_thread`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.Queue.cancel_join_thread) 方法)，那么这个进程在所有缓冲区的对象被刷新进管道之前，是不会终止的。这意味着，**除非你确定所有放入队列中的对象都已经被消费了，否则如果你试图等待这个进程，你可能会陷入死锁中**。相似地(共享队列之中还有数据，但是父进程进行了join())，如果该子进程不是守护进程，并且使用了队列，那么父进程可能在试图等待所有非守护进程退出时挂起。 使用管理器创建队列不会存在这个问题



# 二、生产者消费者队列

## 2.1 构造函数

- `class `multiprocessing.`JoinableQueue`(maxsize)
  - maxsize 队列的容量，默认是无限制的
  - 该队列是`Queue`的子类，继承了父类的所有方法，还额外的提供了两个方法

## 2.2 API

- taks_done()

  - 使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常

- join()

  - 生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止

    ```python
    from multiprocessing import JoinableQueue
    
    # 用法和Queue 相似
    q = JoinableQueue()
    q.put('task1')  # 队列中放入一个任务，内存计数机制 +1
    q.put('task2')  # 计数机制 +1
    
    print(q.get())  # 完成一次任务
    q.task_done()  # 完成一次任务，计数机制 -1
    
    print(q.get())  # 完成一次任务
    # q.task_done()  # 完成一次任务，计数机制 -1
    
    q.join()  # 计数机制不为0的时候，阻塞等待计数器为0 后通过
    
    # 我注释了一个q.task_done()，程序就处于阻塞状态，放开就能通过
    
    print('主')
    
    ```

    

















# 二、管道

## 2.1 构造函数

- ``multiprocessing.``Pipe`([*duplex*])`
  - 返回一对 [`Connection`](https://docs.python.org/zh-cn/3/library/multiprocessing.html#multiprocessing.connection.Connection) 对象 `(conn1, conn2)` ， 分别表示管道的两端
  - 如果 *duplex* 被置为 `True` (默认值)，那么该管道是双向的。如果 *duplex* 被置为 `False` ，那么该管道是单向的，即 `conn1` 只能用于接收消息，而 `conn2` 仅能用于发送消息

# 三、进程间同步

# 四、进程共享

- 在进行并发编程时，**通常最好尽量避免使用共享状**态。使用多个进程时尤其如此

## 4.1 共享内存

- 可以通过使用[`Value`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value) 或 [`Array`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Array)将数据存储在共享内存之中
- 

## 4.2 服务进程

