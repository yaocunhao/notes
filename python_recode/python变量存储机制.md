# 一、可变和不可变类型

-  在python之中，变量分为可变类型和不可变类型

  - 可变类型
    - 列表、字典
  - 不可变类型
    - 数字、字符串、元组

- 这两者本质区别就是，如果改变了变量的值，**是否创建了新的对象，改变了变量的指向，如果是则是不可变的**，反之则是可变的

- **对于不可变的类型，相同的值，在内存之中只有一份**。对于可变的类型，相同的值可能存在多份

  ```python
  l1 = [1, 2, 3, 4, 5]
  l2 = [1, 2, 3, 4, 5]
  
  a = 1
  b = 1
  print(id(l1), id(l2))
  print(id(a), id(b))
  
  # 下面可以看到，可变的类型，相同的值引用的对象地址不一样
  # 不可变的类型，相同的值，引用的对象地址是一样的
  # 140372733812168 140372733963592 
  # 4307118464 4307118464
  
  ```

# 二、对象语义、值语义

- 对象语义
  - python之中变量保存的是值的引用，也就是变量是对内存及其地址的抽象
  - 采用这种方式：**变量所需的存储空间大小一致，因为变量只是保存了一个引用。也被称为对象语义和指针语义。变量的每一次初始化，都开辟了一个新的空间，将新内容的地址赋值给变量**
- 值语义
  - **有些语言采用的不是这种方式，它们把变量的值直接保存在变量的存储区里，这种方式被我们称为值语义，例如C语言，采用这种存储方式，每一个变量在内存中所占的空间就要根据变量实际的大小而定，比如 c中 int 一般为2个字节 而char为一个字节**

# 三、对变量的改变

## 3.1 对于不可变的数据

- 对于不可变的数据，python之中，改变的其实是变量中的地址，即引用的对象不一样了

![image-20220404210808367](../../图片记录/image-20220404210808367.png)	

- 对变量进行赋值时，变量的地址会发生改变，但是相同地址的值是不会变化的。这是因为每一次赋值都会产生一个新的空间地址，将新的空间地址赋值给变量

```python
a = 123
b = a

print("befor:", id(a), id(b))

a += 1
print("value:", a, b)
print("after:", id(a), id(b))

# 可以看到a前后的地址和值发生了变化，而b没有
# befor: 4307245248 4307245248
# value: 124 123
# after: 4307245280 4307245248
```

## 3.2 对于可变的数据

- 如果是执行appen等操作，还是在原来的空间上进行，如果采用的是 `=`赋值操作，那么就使用了新的空间

  ```python
  l1 = [1, 2, 3, 4, 5]
  l2 = l1
  l3 = l1[:]
  
  print(id(l1), id(l2), id(l3))
  
  # 很明显，切片赋值和copy是一样的，都会新开辟一个变量，然后进行引用
  # 而 l2=l1 则是将原来的对象又引用了一次
  # 140214882229704 140214882229704 140214882381128
  
  ```

## 3.3 采用这种引用方式的优缺点

- python之中采用的是引用计数的方式，当变量引用的数量为零的时候，就自动进行垃圾回收
- 优点
  - 对象被多次引用，也就是减少了内存的开销，提高了空间的利用率
- 缺点
  - 会在一定程度上带来性能的损耗

# 三、函数中进行传递

- 值传递

  - 进行函数传参的时候，函数会先生成一个对象的副本，也就是说函数执行的前后，实参不会变化
  - 在进行函数传参的时候，如果形参是**可变类型**，形参的改变才会影响实参，因为不可变的类型引用的时候是同一个对象，但是在改变的时候会创建新的空间，如果想要改变实参，则需要使用return的方式返回一个对象，外边的实参再去改变指向，指向返回的对象

- 引用传递

  - 形参和实参指向的是同一个对象，函数中的修改会影响外边

  - 如果对在函数内部，对**可变对象**使用`=`进行整体赋值，也会改变变量的指向

  ```python
  def func(value):
      print(id(value))
      value = 2
      print(id(value))
  
  
  a = 1
  print(id(a))
  func(a)
  print(id(a))
  # 可以看到，值传递的时候其实也是引用，但是修改的时候会开辟新的变量和改变指向
  # 4490344832
  # 4490344832
  
  # 4490344864
  
  # 4490344832
  
  # ---------------------------#
  
  def func(value):
      print(id(value))
      value['a'] = 2
      print(id(value))
      value = {'a': 10000}
      print(id(value))
  
  
  dic = {'a': 1}
  print(id(dic), dic)
  func(dic)
  print(id(dic), dic)
  
  # 从结果中可以看到，函数内部的改变会影响外边，因为是同一个引用
  # 如果采用 = 进行赋值，则会重新开辟空间进行引用，因此地址发生变化
  # 140616444258848 {'a': 1}
  # 140616444258848
  # 140616444258848
  
  # 140616444259208
  
  # 140616444258848 {'a': 2}
  ```

  