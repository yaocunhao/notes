# 一、addrinfo

- [参考链接](https://blog.csdn.net/zhushengbing11090/article/details/84776724?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167949730916800180669697%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167949730916800180669697&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-84776724-null-null.142^v76^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=addrinfo&spm=1018.2226.3001.4187)

```c
struct addrinfo {
	int	ai_flags;	/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */ 指示在getaddrinfo函数中使用的选项的标志。
	int	ai_family;	/* PF_xxx */
	int	ai_socktype;	/* SOCK_xxx */
	int	ai_protocol;	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */ 主机的规范名称
	socklen_t ai_addrlen;	/* length of ai_addr */  指向的缓冲区的长度（以字节为单位）
	char	*ai_canonname;	/* canonical name for hostname */
	struct	sockaddr *ai_addr;	/* binary address */ 指向 sockaddr 结构的指针。每个返回的addrinfo结构中的ai_addr成员指向一个填充的套接字地址结构(用于绑定)
	struct	addrinfo *ai_next;	/* next structure in linked list */
};
```

- ai_socktype 套接字类
  - SOCK_STREAM：tcp字节流数据传输
  - SOCK_DGRAM：udp数据包无连接传输
  - SOCK_RAW：提供一个原始套接字，允许应用程序处理下一个上层协议头。要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。要操作IPv6头，必须在套接字上设置IPV6_HDRINCL套接字选项
  - SOCK_RDM: windows 使用
  - SOCK_SEQPACKET：基于数据报提供伪流包
- ai_family 使用的协议族
  - AF_UNSPEC   地址系列未指定
  - <font color=yellow>**AF_INET     IPv4 address family**</font>
  - <font color=yellow>**AF_INET6    IPv6 address family**</font>
  - AF_NETBIOS  NetBIOS地址系列
  - AF_IRDA     The Infrared Data Association address family.
  - AF_BTH      Bluetooth address family.
- ai_protocol 使用的协议类型
  - **指定为0，表示使用默认协议，SOCK_DGRAM就是使用udp协议，SOCK_STREA就是使用tcp协议**
  - 如果为ai_protocol指定了值0，则调用者不希望指定协议，服务提供者将选择要使用的ai_protocol。 **对于IPv4和IPv6之外的协议，将ai_protocol设置为零**
  - IPPROTO_TCP  传输控制协议（TCP）。 当ai_family成员为AF_INET或AF_INET6且ai_socktype成员为SOCK_STREAM时，这是一个可能的值
    IPPROTO_UDP  用户数据报协议（UDP）。 当ai_family成员为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。
  - IPPROTO_RM   PGM协议用于可靠的组播。 当ai_family成员为AF_INET且ai_socktype成员为SOCK_RDM时，这是一个可能的值。 在为Windows Vista及更高版本发布的Windows SDK上，此值也称为 IPPROTO_PGM。

# 二、getaddrinfo

- [参考链接](https://blog.csdn.net/qq_45644525/article/details/114239754?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-1-114239754-blog-97769506.235^v26^pc_relevant_recovery_v2&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

- IPv4中使用 [gethostbyname()函数](http://www.cnblogs.com/cxz2009/archive/2010/11/19/1881611.html)完成主机名到地址解析，这个函数仅仅支持IPv4，且不允许调用者指定所需地址类型的任何信息，返回的结构只包含了用于存储IPv4地址的空间。IPv6中引入了getaddrinfo()的新API，它是协议无关的，既可用于IPv4也可用于IPv6。getaddrinfo函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个addrinfo的结构（列表）指针而不是一个地址清单。这些addrinfo结构随后可由套接口函数直接使用。如此以来，getaddrinfo函数把协议相关性安全隐藏在这个库函数内部。应用程序只要处理由getaddrinfo函数填写的套接口地址结构。该函数在 POSIX规范中定义了。

- 函数接口

  ```c
  // 通过该函数返回一个指向addrinfo 结构体链接表的指针
  // addrinfo是socker参数结构体的通用方式，sockaddr_in 是ipv4， sockaddr_un 是系统内域间通信
  int getaddrinfo(const char *node, const char *service,
                     const struct addrinfo *hints,
                     struct addrinfo **res);
                     
                     
  ```

  - 参数需要提供主机名，服务名，或二者都提供。如果仅仅只提供名字，另一个必须是空指针。主机名可以是点分十进制或节点名格式的主机地址
  - node: 一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)，<font color= yellow>其实就是当前服务器的ip地址</font>
  - service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等
  - hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息
  - res：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。
  - 返回值：0——成功，非0——出错

- 总结：<font color=yellow>也就是说，通过填写addrinfo结构体，然后将这个结构体交给geraddrinfo接口，就可以得到一个直接传递个给socket接口的地址信息结构体。比如自己写了提个addrdr_in 结构体，在填充ip和端口的时候需要自己进行处理解析(ip转换成字符串，端口转成大端字节序)</font>

