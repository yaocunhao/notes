# 一、addrinfo

- [参考链接](https://blog.csdn.net/u011003120/article/details/78277133)

- [参考链接](https://blog.csdn.net/zhushengbing11090/article/details/84776724?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167949730916800180669697%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167949730916800180669697&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-84776724-null-null.142^v76^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=addrinfo&spm=1018.2226.3001.4187)
- [使用方式参考链接](https://blog.csdn.net/CM_STC89C52/article/details/127751917?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-127751917-blog-78277133.235^v27^pc_relevant_t0_download&spm=1001.2101.3001.4242.1&utm_relevant_index=2)

## 1.1 基本介绍

- addrinfo结构描述了用于TCP/IP的地址信息。要获得此信息，调用getaddrinfo();要释放这些结构的链表，请调用freeaddrinfo()。

```c
struct addrinfo {
	int	ai_flags;	/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */ 指示在getaddrinfo函数中使用的选项的标志。
	int	ai_family;	/* PF_xxx */
	int	ai_socktype;	/* SOCK_xxx */
	int	ai_protocol;	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */ 主机的规范名称
	socklen_t ai_addrlen;	/* length of ai_addr */  指向的缓冲区的长度（以字节为单位）
	char	*ai_canonname;	/* canonical name for hostname */
	struct	sockaddr *ai_addr;	/* binary address */ 指向 sockaddr 结构的指针。每个返回的addrinfo结构中的ai_addr成员指向一个填充的套接字地址结构(用于绑定)
	struct	addrinfo *ai_next;	/* next structure in linked list */
};
```

- ai_flags
  
  ```
  AI_PASSIVE     套接字地址将用于调用bind 函数
  AI_CANONNAME   返回规范名称
  AI_NUMERICHOST 传递给getaddrinfo函数的nodename参数必须是数字字符串。
  AI_ALL         If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED.
  AI_ADDRCONFIG  只有配置了全局地址后，getaddrinfo才会解析。 IPv6和IPv4环回地址不被认为是有效的全局地址。
  AI_V4MAPPED    如果对IPv6地址的getaddrinfo请求失败，则对IPv4地址进行名称服务请求，这些地址将转换为IPv4映射IPv6地址格式。
  AI_NON_AUTHORITATIVE 地址信息可以来自非授权命名空间提供商
  AI_SECURE      地址信息来自安全信道。
  AI_RETURN_PREFERRED_NAMES 地址信息是用于用户的优选名称。
  AI_FQDN        getaddrinfo将返回名称最终解析为的完全限定域名。 完全限定域名在ai_canonname成员中返回。
  ```
  
- ai_socktype 套接字类![image-20230324101745162](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202303241017631.png)
  
  - SOCK_STREAM：tcp字节流数据传输
  - SOCK_DGRAM：udp数据包无连接传输
  - SOCK_RAW：提供一个原始套接字，允许应用程序处理下一个上层协议头。要操作IPv4标头，必须在套接字上设置IP_HDRINCL套接字选项。要操作IPv6头，必须在套接字上设置IPV6_HDRINCL套接字选项
  - SOCK_RDM: windows 使用
  - SOCK_SEQPACKET：基于数据报提供伪流包
- ai_family 使用的协议族
  - AF_UNSPEC   地址系列未指定
  - <font color=yellow>**AF_INET     IPv4 address family**</font>
  - <font color=yellow>**AF_INET6    IPv6 address family**</font>
  - AF_NETBIOS  NetBIOS地址系列
  - AF_IRDA     The Infrared Data Association address family.
  - AF_BTH      Bluetooth address family.
- ai_protocol 使用的协议类型
  - **指定为0，表示使用默认协议，SOCK_DGRAM就是使用udp协议，SOCK_STREA就是使用tcp协议**
  - 如果为ai_protocol指定了值0，则调用者不希望指定协议，服务提供者将选择要使用的ai_protocol。 **对于IPv4和IPv6之外的协议，将ai_protocol设置为零**
  - IPPROTO_TCP  传输控制协议（TCP）。 当ai_family成员为AF_INET或AF_INET6且ai_socktype成员为SOCK_STREAM时，这是一个可能的值
    IPPROTO_UDP  用户数据报协议（UDP）。 当ai_family成员为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。
  - IPPROTO_RM   PGM协议用于可靠的组播。 当ai_family成员为AF_INET且ai_socktype成员为SOCK_RDM时，这是一个可能的值。 在为Windows Vista及更高版本发布的Windows SDK上，此值也称为 IPPROTO_PGM。

## 1.2 为何使用

- addrinfo结构描述了用于TCP/IP的地址信息。要获得此信息，调用getaddrinfo();要释放这些结构的链表，请调用freeaddrinfo()
- 通常是在创建客户端的时候填充这些信息， 通过getaddrinfo 获取到返回的信息，<font color=yellow>主要目的是将ip地址和端口号转换成**网络套接字结构体**</font>

# 二、getaddrinfo

## 2.1 基本介绍

- [参考链接](https://blog.csdn.net/qq_45644525/article/details/114239754?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-1-114239754-blog-97769506.235^v26^pc_relevant_recovery_v2&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

- IPv4中使用 [gethostbyname()函数](http://www.cnblogs.com/cxz2009/archive/2010/11/19/1881611.html)完成主机名到地址解析，这个函数仅仅支持IPv4，且不允许调用者指定所需地址类型的任何信息，返回的结构只包含了用于存储IPv4地址的空间。IPv6中引入了getaddrinfo()的新API，它是协议无关的，既可用于IPv4也可用于IPv6。getaddrinfo函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个addrinfo的结构（列表）指针而不是一个地址清单。这些addrinfo结构随后可由套接口函数直接使用。如此以来，getaddrinfo函数把协议相关性安全隐藏在这个库函数内部。应用程序只要处理由getaddrinfo函数填写的套接口地址结构。该函数在 POSIX规范中定义了。

- 函数接口

  ```c
  // 通过该函数返回一个指向addrinfo 结构体链接表的指针
  // addrinfo是socker参数结构体的通用方式，sockaddr_in 是ipv4， sockaddr_un 是系统内域间通信
  int getaddrinfo(const char *node, const char *service,
                     const struct addrinfo *hints,
                     struct addrinfo **res);
                     
                     
  ```

  - 参数需要提供主机名，服务名，或二者都提供。如果仅仅只提供名字，另一个必须是空指针。主机名可以是点分十进制或节点名格式的主机地址
  - node: 一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)，<font color= yellow>其实就是当前服务器的ip地址</font>
  - service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等。<font color=yellow>其实就是端口号</font>
  - hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息
  - res：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。
  - 返回值：0——成功，非0——出错

## 2.2 作用

- <font color=yellow>也就是说，通过填写addrinfo结构体，然后将这个结构体交给geraddrinfo接口，就可以得到一个直接传递个给socket接口的地址信息结构体。比如自己写了个addrdr_in 结构体，在填充ip和端口的时候需要自己进行处理解析(ip转换成字符串，端口转成大端字节序)</font>
- 通过getaddrinfo获取的结构体可以强转成sockaddr_in 结构体，**直接用于ip和地址的绑定**。**或者将ip和地址转换成网络字节序，手动的填充sockaddr_in 结构体，然后将该结构体用于服务器的绑定**

## 2.3 代码示例

```c++
#include <iostream>
using namespace std;
#include <netdb.h>
#include <cstring>

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>

// 测试addrinfo 和 getadrinfo

int main()
{
  struct addrinfo addres, *ai_addres, *aip;
  // 初始化
  memset(&addres, 0, sizeof(addres));
  // 填充结构体信息
  addres.ai_family = AF_UNSPEC;     //使用的协议族未知
  addres.ai_socktype = SOCK_STREAM; // 套接字类型为 流的形态
  addres.ai_flags = AI_PASSIVE;     // 生成的套接字可以直接用于绑定
  addres.ai_protocol = 0;           // 为0表示， stream使用tcp协议,SOCK_DGRAM使用udp协议
  char ipbf[16];
  char i_port[100] = {0}; // 网络字节序端口

  // 通过getaddrinfo 接口获取信息
  // 获取的信息会填充到ai_addres 之中，
  const char *hostname = "127.0.0.1";
  const char *port = "8000";
  int err = getaddrinfo(hostname, port, &addres, &ai_addres);
  if (err != 0)
  {
    cout << "获取信息error" << endl;
    // gai_strerror 获取系统调用接口错误的信息
    printf("str_error = %s\n", gai_strerror(errno));
  }

  // output the information returned by the getaddrinfo
  cout << "ai_family:" << ai_addres->ai_family << endl;     // 2, tcp协议
  cout << "ai_addrlen:" << ai_addres->ai_addrlen << endl;   // 16, sockaddr 结构体大小
  cout << "ai_flags:" << ai_addres->ai_flags << endl;       // 0，标识
  cout << "ai_socktype:" << ai_addres->ai_socktype << endl; // 1， 套接字类型，这里是SOCK_STREAM
  // cout << "ai_canonname:" << ai_addres->ai_canonname << endl; //  主机的名称， 这里没有
  cout << "sa_family:" << ai_addres->ai_addr->sa_family << endl; // a_family:
  cout << "sa_data:" << ai_addres->ai_addr->sa_data << endl;     // sockaddr是通用的套接字结构体，因此这里无法直接输出有效内容，需要转换成sockaddr_in

  // 返回的ai_addres 是一个链表
  for (aip = ai_addres; aip != NULL; aip = aip->ai_next)
  {
    struct sockaddr_in *addr = (struct sockaddr_in *)aip->ai_addr;
    cout << "n_ip:" << addr->sin_addr.s_addr << " "
         << "n_port:" << addr->sin_port << endl;        // n_ip:16777343 n_port:16415
    inet_ntop(AF_INET, &addr->sin_addr, ipbf, 16);      // 将网络字节序ip转成点分十进制
    inet_ntop(AF_INET, &addr->sin_port, i_port, 100);   // 将网络字节序ip转成点分十进制
    cout << "ip:" << ipbf << "port:" << i_port << endl; // ip:127.0.0.1 port:31.64.127.0
    cout << "h_ip:" << ntohl(addr->sin_addr.s_addr) << " "
         << "h_port:" << ntohs(addr->sin_port) << endl; // 网络字节序-> 主机字节序 h_ip:2130706433 h_port:8000
  }
  cout << "end..." << endl;
  freeaddrinfo(ai_addres); // getaddrinfo 返回的结构体的空间是动态开辟的，因此需要手动的释放内存

  return 0;
}
```

# 三、主机字节序和网络字节序转换

- ## 3.1 主机字节序转换为网络字节序

  ```c
  // 主机字节序转化为网络字节序
  htonl() // ip 转换
  htons // 端口转换
  
  // 网络字节序转化为主机字节序， 这里转换后是int的形态
  ntohl()
  ntohs()
  
  // 将字符串变成四字节ip地址 , 并且是网络字节序
  in_addr_t inet_addr(const char *cp)
    
  // 将网络字节序转换成点分十进制字符串,inet_ntoa只适用于ipv4地址，而inet_ntop适用ipv4和ipv6地址
  inet_ntop、inet_ntoa
  ```


# 四、fcnt

- [参考链接](https://blog.csdn.net/fengxinlinux/article/details/51980837?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167953943416800182710501%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167953943416800182710501&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-51980837-null-null.142^v76^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=fcntl&spm=1018.2226.3001.4187)
- 系统调用，可用来对已经打开的文件描述符进行各种控制操作以改变已打开文件的各种属性



# 五、其余接口

## 5.1 getpeername、getsockname

- [参考链接](https://blog.csdn.net/chenliang0224/article/details/80574808?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167989373716800180641885%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167989373716800180641885&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-10-80574808-null-null.142^v76^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=getsockname&spm=1018.2226.3001.4187)
- getsockname函数用于获取与某个[套接字](https://so.csdn.net/so/search?q=套接字&spm=1001.2101.3001.7020)关联的本地协议地址。getpeername函数用于获取与某个套接字关联的外地协议地址
- 对于这两个函数，如果函数调用成功，则返回0，如果调用出错，则返回-1。
- getsockname
  - 在服务端：bind后通过绑定sockfd获取本地信息，在accept后可以通过链接fd获取本地信息
  - 在客户端：在调用connect后可以通过sockfd获取本地信息

- getpeername:
  - 服务器通过链接fd获取客户端信息




## 5.2  设置端口可以立即被绑定

```c
int setsockopt(int, int, int, const void *, socklen_t)
  
```



# 六、数据的收发

- send
