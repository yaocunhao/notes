# 一、简单工厂模式

- 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过**使用一个共同的接口来指向新创建的对象**
- 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使**一**个类的实例化延迟到其子类

- **适用性**

  - 当一个类不知道它所必须创建的对象的类的时候
  - 当一个类希望由它的子类来指定它所创建的对象的时候
  - 当类将创建对象的职责委托给多个子类中的某一个

- 优点

  - 定义创建对象的接口，封装了对象创建的过程
  - 使具体化类的工作延迟到了子类之中
  - 客户端不需要修改代码

- 缺点

  - 程序员必须知道子类的名字,当子类非常多的时候命名是一件非常麻烦的事情
  - 在父类之中并不知道具体要实例化哪一个具体的子类
  - 需要增加新的运算类的时候，不仅需新加运算类，还要修改工厂类，违反了开闭原则

  ```python
  # 提供一个食物工厂类，通过该接口进行实例化，可以获取不同的食物
  
  
  class Beff:
  
    def price(self):
      print('beff 100')
  
  
  class Fruit:
  
    def price(self):
      print('fruit 200')
  
  
  class FoodFactory:
  
    def create(self, food):
      if food == 'Beff':
        return Beff()
      elif food == 'Fruit':
        return Fruit()
      else:
        return None
  
  
  fac = FoodFactory()  # 实例化工厂类
  
  # 通过工厂类进行实例化
  obj = fac.create('Fruit')
  obj.price()
  ```

  

# 二、工厂模式

- 这个和简单工厂有区别，简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的工厂
  - 好处：增加一个运算类（例如N次方类），只需要增加运算类和相对应的工厂，两个类，不需要修改工厂类
  - 缺点：增加运算类，会修改客户端代码，工厂方法只是把简单工厂的内部逻辑判断移到了客户端进行

```python
class FoodFactory:
  # 工厂类
  def get_food(self):
    return self.food_name


class Beff(FoodFactory):

  def __init__(self) -> None:
    self.food_name = 'beff'

  def price(self):
    print('beff 100')


class Fruit(FoodFactory):

  def __init__(self) -> None:
    self.food_name = 'fruit'

  def price(self):
    print('fruit 200')


# 接口基类 ，继承规范接口
class FoodInterfaceFactory:
  # 接口基类
  @abstractmethod
  def create(self):
    pass



# 增加一种食物提供一个类
class FoodBeff(FoodInterfaceFactory):
  def create(self):
    return Beff()


class FoodFruit(FoodInterfaceFactory):
  def create(self):
    return Fruit()


b = FoodBeff()
b = b.create()
b.get_food()
b.price()
```

