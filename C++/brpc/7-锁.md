- [使用标准锁可能会导致死锁](https://github.com/apache/brpc/issues/2313)
- [使用bthread时，不能在pthread锁临界区内执行会挂起bthread的操作（bthread_mutex、rpc、bthread_usleep等）。否则，会导致死锁或者其他未定义行为](https://github.com/apache/brpc/issues/2456)
  - 比如当前bthread拿到了线程锁，然后rpc，当前bthread被挂起，意味着当前线程锁被占用了，后续的任意操作(包括调度bthread)，都会因为拿不到锁被挂起。然后当前bthread 可能会被其他工作pthread 唤醒，那也就意味着之前的线程锁丢了，导致未定义行为(比如切换回来时线程变了，但是锁在这个线程中，就出现了问题)
  - bthread 等待拿锁时不会切换线程
- [Bthread 只会因为bthread 函数和rpc 而挂起](https://www.iquanku.com/read/brpc-0.9.7-zh/adb9e61c135a61a7.md#:~:text=%E9%98%BB%E5%A1%9E%E4%BC%9A%E5%BD%B1%E5%93%8D-,%E5%85%B6%E4%BB%96,-bthread%E5%90%97%EF%BC%9F)
  - 若bthread因bthread API而阻塞，它会把当前pthread worker让给其他bthread。若bthread因pthread API或系统函数而阻塞，当前pthread worker上待运行的bthread会被其他空闲的pthread worker偷过去运行。也就是说当前bthread因为pthread或者系统函数被挂起时，线程只会等待运行当前的bthread。(待写代码验证)
  - 从此可知，bthread 拥有pthread 锁时，避免在临界区执行bthred 自身提供的挂起函数和进行rpc调用即可避免死锁问题