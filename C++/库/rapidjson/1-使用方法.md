# 一、基本概念

- 将json字符串序列化成Document对象。document 对象之中提供了一系列的访问和修改方法

# 二、常用 API 

- [turorial code](https://github.com/Tencent/rapidjson/blob/master/example/tutorial/tutorial.cpp)

- `json` 字符串序列化成`Document`对象

  ```c++
  #if 0
      // 常规将json字符串序列化成Document对象，会分配新的内存
      // "normal" parsing, decode strings to new buffers. Can use other input stream via ParseStream().
      if (document.Parse(json).HasParseError())
          return 1;
  #else
    // 原位解析，会在直接输入的字符串上进行修改(这里copy了一个buffer)
    // 由于这里是演示所用，所有没有直接序列化修改传入的json，而是copy了一份buffer出来
    // In-situ parsing, decode strings directly in the source string. Source must
    // be string.
    char buffer[sizeof(json)];
    memcpy(buffer, json, sizeof(json));
    if (document.ParseInsitu(buffer).HasParseError()) return 1;
  #endif
  ```
  
- 访问某个字段的值

  ```c++
  // 1.通过document 对象进行访问
  document["hello"].GetString()
    
  // 2.通过迭代器访问成员的值
  Value::MemberIterator hello = document.FindMember("hello");
  std::cout<<"通过迭代器访问成员的值："<<hello->value.GetString()<<std::endl;
  
  // 3.通过引用对象字段进行访问
    const Value& t = document["t"];
    std::cout << "通过Value引用对象进行访问:" << t.GetBool() << std::endl;
  ```

- 修改某个字段的值

  ```c++
    std::cout << "修改之前的值是：" << document["i"].GetInt64() << std::endl;
    {
      uint64_t f20 = 1;  // compute factorial of 20
      for (uint64_t j = 1; j <= 20; j++) f20 *= j;
      document["i"] = f20;  // Alternate form: document["i"].SetUint64(f20)
      assert(!document["i"].IsInt());  // No longer can be cast as int or uint.
    }
    std::cout << "修改之后的值是：" << document["i"].GetInt64() << std::endl;
  ```

- check字段的值和类型

  ```c++
  assert(document["t"].IsBool());
  ```

- 增加一个字段

  - **使用Value 构造一个对象，并且填充**
    - Value 填充的初始化方式有，先声明再调用 `SetString`、直接构造
  - document.AddMember 进行成员对象的添加。第一个参数是(原始字符串("12312")，或者Value类型)
  
  ```c++
    Value author;
    {
      char buffer2[] = "1231232131";
      int len =sizeof(buffer2);
      author.SetString(buffer2, static_cast<SizeType>(len),
                       document.GetAllocator());
      
      // Shorter but slower version:
      //  hello对应的值已经存在了，才能像下面这样写
      // document["hello"].SetString(buffer, document.GetAllocator());
  		
      //  设置Value对象的值构造函数版本(带长度和不带长度)
      // Value author(buffer, len, document.GetAllocator());
      // Value author(buffer, document.GetAllocator());
    }
    // Variable 'buffer' is unusable now but 'author' has already made a copy.
    document.AddMember("author", author, document.GetAllocator());
  
  
    Value add_value;
    add_value.SetString("112312321");
    document.AddMember("add_key", add_value, document.GetAllocator());
  
  
  
  // 进行批量添加
    Document d;
  // 使用 req_params.SetObject() 或者 req_params.SetArray() 来初始化为对象或数组类型。
    d.SetObject();  // 初始化Document为一个对象
  
    // 使用初始化列表定义多个键值对
    std::vector<std::pair<const char*, const char*>> keyValuePairs = {
        {"key1", "a"}, {"key2", "value2"}, {"key3", "value3"}};
  
    // 遍历键值对并添加到document
    for (const auto& kv : keyValuePairs) {
      Value key(kv.first, d.GetAllocator());
      Value value(kv.second, d.GetAllocator());
      d.AddMember(key, value, d.GetAllocator());
    }
  
    // 将Document转换为字符串以便打印
    StringBuffer buffer;
    Writer<StringBuffer> writer(buffer);
    d.Accept(writer);
  
  ```
  
- 读取的值不存在会导致程序宕掉，因此需要做一些判断，其中`Null`也需要判断

  ```c++
      if (!body_json.IsObject() || !body_json.HasMember("data") ||
          body_json["data"].IsNull() ||
          !body_json["data"].HasMember("download_url")) {
        LOG(ERROR) << "Get download url faild,body is:" << body;
        return "";
      }
  ```
  
  
  
- 反序列化document 对象

  ```c++
    printf("\nModified JSON with reformatting:\n");
    StringBuffer sb;
    PrettyWriter<StringBuffer> writer(sb);
    document.Accept(
        writer);  // Accept() traverses the DOM and generates Handler events.
    puts(sb.GetString());
  
    std::cout << "Source json string:" << json << std::endl;
    std::cout << "Source buffer string:" << sb.GetString() << std::endl;
  ```

  