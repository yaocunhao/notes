- 状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，即不同的状态对应了不同的行为。对象看起来似乎修改了它的类
- 优点
  - 封装了状态的转换规则，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中
  - 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为
  - 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起
  - 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
- 缺点
  - 会增加系统中类和对象的个数，导致系统运行开销增大
  - 结构与实现都较为复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计的难度
  - 对开闭原则的支持并不太好，增加新的状态类需要修改负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需要修改对应类的源代码

```python
class Connection1:
  """ 新方案——对每个状态定义一个类，Connection1类为主类"""

  def __init__(self):
    # 初始状态为closed状态，为ClosedConnectionState的实例
    self.new_state(ClosedConnectionState)

  def new_state(self, newstate):
    self._state = newstate  # Delegate to the state class

  def read(self):
    # 调用的是所属实例的方法（Close/Open）
    return self._state.read(self)

  def write(self, data):
    return self._state.write(self, data)

  def open(self):
    return self._state.open(self)

  def close(self):
    return self._state.close(self)


# Connection state base class
class ConnectionState:

  @staticmethod
  def read(conn):
    # 子类必须实现父类的方法，否则报下列错误
    raise NotImplementedError()

  @staticmethod
  def write(conn, data):
    raise NotImplementedError()

  @staticmethod
  def open(conn):
    raise NotImplementedError()

  @staticmethod
  def close(conn):
    raise NotImplementedError()


# Implementation of different states
class ClosedConnectionState(ConnectionState):

  @staticmethod
  def read(conn):
    raise RuntimeError('Not open')

  @staticmethod
  def write(conn, data):
    raise RuntimeError('Not open')

  @staticmethod
  def open(conn):
    conn.new_state(OpenConnectionState)

  @staticmethod
  def close(conn):
    raise RuntimeError('Already closed')


class OpenConnectionState(ConnectionState):

  @staticmethod
  def read(conn):
    print('reading')

  @staticmethod
  def write(conn, data):
    print('writing')

  @staticmethod
  def open(conn):
    raise RuntimeError('Already open')

  @staticmethod
  def close(conn):
    # 转换为Close实例，调用父类的new_state方法
    conn.new_state(ClosedConnectionState)


if __name__ == '__main__':
  c = Connection1()
  print(c._state)
  c.open()
  print(c._state)
  c.read()
  c.write("write")
  c.close()
  print(c._state)

```

![image-20221010091622359](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202210100916174.png)