

# 一、基本介绍

- 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

- 当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时；或者当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些
- 原型模式原型模式是一种不太常见的创建型模式，我们平时的工作中几乎不会遇到这种模式，但是在一些框架设计中会用到，这里我们只做了解即可。它解决的也是对象创建时的问题，如果从代码层面上来看，它可以看作是工厂方法的一种巧妙的变化

```python
import copy


class Base:

  def __init__(self):
    self.__objects = {}

  # 添加新的对象
  def create(self, name, obj):
    self.__objects[name] = obj

  # 根据名字删除对象
  def remove(self, name):
    del self.__objects[name]

  # 在已经有的基础对象上，进行改造
  def add(self, name, **kwargs):
    obj = copy.deepcopy(self.__objects.get(name))
    obj.__dict__.update(kwargs)  # 在原来基础上添加方法或参数
    return obj


class Food:

  def price():
    print('free')


def name():
  print('this is beff!!')


b = Base()
f = Food()
b.create('food', f)  # 将对象添加进去
ret = b.add('food', func=name)  # 找到'food'对应的对象，然后给其添加一个方法
ret.func()  # this is beff!!

# 为什么交原型方法呢
# 首先创建原型对象，全部填充到基础类之中
# 然后通过调用add方法，传入对应的name获取对应的对象后，给其添加新的方法或者变量
# 也就是说，在原型的基础上进行功能的增加和修改
```

```c++

```

