# 一、简单工厂模式

- <font color=yellow>如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：**解耦**</font>
- 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过**使用一个共同的接口来指向新创建的对象**
- 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使**一**个类的实例化延迟到其子类

- **适用性**

  - 当一个类不知道它所必须创建的对象的类的时候
  - 当一个类希望由它的子类来指定它所创建的对象的时候
  - 当类将创建对象的职责委托给多个子类中的某一个
  - 比如，现在一个类来描述车，但是车的平台有很多，这样每一种车品牌都需要手动的去创建对象。这种就符合工厂模式，通过一个接口，来进行对象的创建，缺点就是每添加一种新的品牌，都需要修改原来的代码，不符合闭开原则

- 优点

  - 定义创建对象的接口，封装了对象创建的过程
  - 使具体化类的工作延迟到了子类之中
  - 客户端不需要修改代码

- 缺点

  - 程序员必须知道子类的名字,当子类非常多的时候命名是一件非常麻烦的事情
  - 在父类之中并不知道具体要实例化哪一个具体的子类
  - 需要增加新的运算类的时**候，不仅需新加运算类，还要修改工厂类，违反了开闭原则**

  ```python
  # 提供一个食物工厂类，通过该接口进行实例化，可以获取不同的食物
  
  
  class Beff:
  
    def price(self):
      print('beff 100')
  
  
  class Fruit:
  
    def price(self):
      print('fruit 200')
  
  
  class FoodFactory:
  
    def create(self, food):
      if food == 'Beff':
        return Beff()
      elif food == 'Fruit':
        return Fruit()
      else:
        return None
  
  
  fac = FoodFactory()  # 实例化工厂类
  
  # 通过工厂类进行实例化
  obj = fac.create('Fruit')
  obj.price()
  ```

  

# 二、工厂模式

- 这个和简单工厂有区别，简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的工厂
  - 优点：符合必开原则，每次创建新的'品牌'不需要修改原来的代码，只需要增加一个新类即可
  - 缺点：每增加一种产品就需要增加一个类，当种类特别多时，需要增加的类就特别多

```python
class FoodFactory:
  # 工厂类
  def get_food(self):
    return self.food_name


class Beff(FoodFactory):

  def __init__(self) -> None:
    self.food_name = 'beff'

  def price(self):
    print('beff 100')


class Fruit(FoodFactory):

  def __init__(self) -> None:
    self.food_name = 'fruit'

  def price(self):
    print('fruit 200')


# 接口基类 ，继承规范接口
class FoodInterfaceFactory:
  # 接口基类
  @abstractmethod
  def create(self):
    pass



# 增加一种食物提供一个类
class FoodBeff(FoodInterfaceFactory):
  def create(self):
    return Beff()


class FoodFruit(FoodInterfaceFactory):
  def create(self):
    return Fruit()


b = FoodBeff()
b = b.create()
b.get_food()
b.price()
```

# 三、抽象工厂模式

- 抽象工厂，通常用来描述产品族模型

- 由于抽象工厂定义的一系列对象通常是相关或相互依赖的，这些产品对象就构成了一个产品族，也就是抽象工厂定义了一个产品族。这就带来非常大的灵活性，切**换产品族的时候，只要提供不同的抽象工厂实现就可以了，也就是说现在是以一个产品族作为一个整体被切换**

- 在什么情况下应当使用抽象工厂模式
  - 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的
  - 这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品
  - 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来（比如：Intel主板必须使用Intel CPU、Intel芯片组）
  - 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现
- 抽象工厂模式的缺点
  - 不太容易扩展新的产品。如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类![image-20220628095245424](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202206280952575.png)

```python
# 抽象工厂
class AbstractFactory(object):
  computer_name = ''
  # CPU
  def createCpu(self):
    pass

  #  主板
  def createMainboard(self):
    pass


# inter 零件工厂
class IntelFactory(AbstractFactory):
  computer_name = 'Intel I7-series computer '

  def createCpu(self):
    return IntelCpu('I7-6500') # 通过零件类创建对象

  def createMainboard(self):
    return IntelMainBoard('Intel-6000')


class AmdFactory(AbstractFactory):
  computer_name = 'Amd 4 computer '

  def createCpu(self):
    return AmdCpu('amd444')

  def createMainboard(self):
    return AmdMainBoard('AMD-4000')


# 抽象CPU类
class AbstractCpu(object):
  series_name = ''
  instructions = ''
  arch = ''

# Inter CPU类
class IntelCpu(AbstractCpu):

  def __init__(self, series):
    self.series_name = series

# Amd Cpu类
class AmdCpu(AbstractCpu):
  def __init__(self, series):
    self.series_name = series


# 抽象主板类
class AbstractMainboard(object):
  series_name = ''

# inter 主板类
class IntelMainBoard(AbstractMainboard):
  def __init__(self, series):
    self.series_name = series

# amd主板类
class AmdMainBoard(AbstractMainboard):
  def __init__(self, series):
    self.series_name = series


# 通过传入的对象，进行对应的调用
class ComputerEngineer(object):
  def makeComputer(self, factory_obj): # 传入工厂类，然后
    self.prepareHardwares(factory_obj)

  # 准备硬件
  def prepareHardwares(self, factory_obj):
    self.cpu = factory_obj.createCpu() # cpu
    self.mainboard = factory_obj.createMainboard() # 主板

    info = f'computer {factory_obj.computer_name} info:cpu: { self.cpu.series_name} mainboard:{self.mainboard.series_name}'
    print(info)


if __name__ == "__main__":
  engineer = ComputerEngineer()  #装机工程师

  intel_factory = IntelFactory()  #intel工厂
  engineer.makeComputer(intel_factory) # 传入inter

  amd_factory = AmdFactory()  #adm工厂
  engineer.makeComputer(amd_factory) # 传入amd

```

![image-20220628093331514](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202206280933324.png)



# 四、小结

![image-20220918164439723](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202209181644846.png)