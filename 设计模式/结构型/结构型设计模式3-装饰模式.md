- 特点
  - 装饰模式和继承非常像，但是装饰器模式不是采用继承的方式，而是动态的添加一些功能，比继承更加的灵活
- 适用性
  - 当不能采用生成子类的方法进行扩充时(**继承的方式**)
    - 一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得**子类数目呈爆炸性增长**
    - 另一种情况可能是因为类定义被隐藏，或类定义**不能用于生成子类**

```python
 class foo(object):
    def f1(self):
        print("original f1")
 
    def f2(self):
        print("original f2")
 
 
class foo_decorator(object):
    def __init__(self, decoratee):
        self._decoratee = decoratee
 
    def f1(self):
        print("decorated f1")
        self._decoratee.f1()
 
    def __getattr__(self, name):
        return getattr(self._decoratee, name)
 
u = foo()
v = foo_decorator(u)

# 这些都是新添加的，但是又没有对foo进行继承
v.f1()
v.f2() 
```

