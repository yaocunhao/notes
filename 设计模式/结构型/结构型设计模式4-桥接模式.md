- 背景

  - 当一个产品的变化维度比较多时，如果采用传统继承的方式，会导致子类的急剧增加，**充斥着重复的代码，这时候的关键是划清责任**

    - 假设一辆车的组成： 发动机、轮胎
    - 如果采用继承的方式进行实现，如果有10种发动机，10种轮胎就会导致子类急剧增加 10*10 子类![image-20220916110125544](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202209161101907.png)

    

  - 所以桥接模式解决的主要问题是**使得产品适应多种维度的变化**

    - 原来是直接通过继承抽象基类进行接口的重写，桥接模式则是**再在中间添加一层**，然高耦合的**继承方式变成了低耦合的组合方式**

    ![image-20220916110359392](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202209161103495.png)

```c++
#include <iostream>
using namespace std;

// 发动机抽象类-------------------
class Engine
{
public:
  virtual void installEngine() = 0;
};

// 4000 发动机
class Engine4000 : public Engine
{
public:
  virtual void installEngine()
  {
    cout << "安装发动机 Engine4000" << endl;
  }
};

// 3500 发动机
class Engine3500 : public Engine
{
public:
  virtual void installEngine()
  {
    cout << "安装发动机 Engine 3500" << endl;
  }
};

// 轮胎抽象类--------------------
class Tyre
{
public:
  virtual void installTyre() = 0;
};

// 普通轮胎
class TypeNormal : public Tyre
{
public:
  virtual void installTyre()
  {
    cout << "安装普通的轮胎" << endl;
  }
};

// 防滑轮胎
class TypeSnow : public Tyre
{
public:
  virtual void installTyre()
  {
    cout << "安装防滑的轮胎" << endl;
  }
};




// 车类： 对发动机和轮胎进行一个组合
class Car
{
public:
  Car(Engine *engine, Tyre *tyre)
  {
    _engine = engine;
    _tyre = tyre;
  }

  virtual void installCar() = 0;

  Engine *_engine; // 引擎
  Tyre *_tyre;     //轮胎
};

class Car1 : public Car
{
public:
  Car1(Engine *e, Tyre *t) : Car(e, t)
  {
  }

  virtual void installCar()
  {
    cout << "车类型1安装" << endl;
    _engine->installEngine();
    _tyre->installTyre();
  }
};

int main()
{
  Engine3500 *e3500 = new Engine3500; // 创建一个发动机
  TypeNormal *tyre = new TypeNormal;  // 创建一个轮胎

  Car1 *car = new Car1(e3500, tyre); //创建一辆车
  car->installCar();
  delete e3500;
  delete tyre;
  delete car;
  return 0;
}

```

