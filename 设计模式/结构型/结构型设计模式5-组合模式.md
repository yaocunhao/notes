- [Python 版本](https://blog.csdn.net/Htojk/article/details/129950966?ops_request_misc=&request_id=&biz_id=102&utm_term=Python%20%20%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-129950966.142^v96^pc_search_result_base3&spm=1018.2226.3001.4187)
- 是什么
  - 将对象组合成[树形结构](https://so.csdn.net/so/search?q=树形结构&spm=1001.2101.3001.7020)以表示"部分-整体"的层次关.组合模式使得用户**对单个对象和组合对象的使用具有一致性**
- 优点
  - 高层模块调用简单
  - 高度自由
- 缺点
  - 叶子和树枝的声明都是实现类,违反了[依赖倒置原则](https://so.csdn.net/so/search?q=依赖倒置原则&spm=1001.2101.3001.7020)
- 组合模式核心
  - 抽象构建（Component）角色：定义了叶子和容器构件的共同点
  - 容器构建角色（Composite）：有容器特征，可以包含子节点
  - 叶子（Leaf）构件角色：无子节点

- 使用场景
  - 你想表示对象的部分-整体层次结构
  - 你希望用户**忽略组合对象与单个对象的不同**，用户将**统一地使用**组合结构中的所有对象

```python
#include <iostream>
#include <string>
#include <vector>
#include <algorithm> // std::find

using namespace std;

// 操作行为同一接口： 定义抽象的角色(根节点)
class ICompany
{
public:
  virtual string getName() = 0; //功能接口，树枝也叶子节点都需要实现，用户无差别使用该接口

  //容器构建角色使用(树枝)： 可以进行子节点的包含
  virtual void add(ICompany *) = 0;
  virtual void remove(ICompany *) = 0;
  virtual vector<ICompany *> getChild() = 0;
};

// 树枝类： 包含功能都需要实现
class Company : public ICompany
{
public:
  explicit Company(const string &name)
  {
    m_name = name;
  }
  string getName()
  {
    return m_name;
  }

  void add(ICompany *child)
  {
    // 调移动构造
    m_child.push_back(child);
  }

  void remove(ICompany *child)
  {
    m_child.erase(find(m_child.begin(), m_child.end(), child));
  }
  vector<ICompany *> getChild()
  {
    return m_child;
  }

private:
  string m_name;
  vector<ICompany *> m_child;
};

// 叶子类： 只实现功能， 不实现包含
class MinimumCompany : public ICompany
{
public:
  explicit MinimumCompany(const string &name)
  {
    m_name = name;
  }
  string getName()
  {
    return m_name;
  }

  void add(ICompany *)
  {
    // 叶子是最小细分，不具体实现此接口
  }

  void remove(ICompany *)
  {
    // 叶子是最小细分，不具体实现此接口
  }
  vector<ICompany *> getChild()
  {
    // 叶子是最小细分，不具体实现此接口
    vector<ICompany *> vec;
    return vec;
  }

private:
  string m_name;
};

// 从树节点的根部 -> 叶子处 进行打印
//
void printFrame(ICompany *company, int n = 1)
{
  if (!company)
    return;

  for (int i = 0; i < n; i++)
  {
    cout << "-";
  }

  cout << company->getName() << endl;

  if (!company->getChild().empty())
  {

    for (auto &iter : company->getChild())
    {
      printFrame(iter, n + 1); // 进行递归操作，每往下走一层，n+1
    }
  }
}

// 测试模拟：
// 根节点为：食物
// 树枝节点为： 牛肉、水果
// 根节点为： 1、黄牛肉、水牛肉     2、香蕉、苹果

int main()
{
  // 树枝
  ICompany *food_1 = new Company("beef");
  ICompany *food_2 = new Company("furit");

  // 牛肉叶子节点
  ICompany *y_beff = new MinimumCompany("ybeff");
  ICompany *w_beff = new MinimumCompany("wbeff");

  // 水果叶子节点
  ICompany *banana = new MinimumCompany("banana");
  ICompany *apple = new MinimumCompany("apple");

  // 打印
  food_1->add(y_beff);
  food_1->add(w_beff);

  food_2->add(banana);
  food_2->add(apple);

  printFrame(food_1);
  printFrame(food_2);

  return 0;
}

```

