# 一、什么是异常处理

- 程序异常分为运行前异常和运行后异常

  - 运行前异常指的是语法错误，在程序运行之前就能够监测出来
  - 运行后异常指的是代码在运行过程之中出现错误，如果想让程序运行下去，**就需要对异常进行处理**

- 常见的异常类型

  - [异常类型大全](https://blog.csdn.net/qq_34238567/article/details/120737720?ops_request_misc=&request_id=&biz_id=102&utm_term=python%20%E5%BC%82%E5%B8%B8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-120737720.nonecase&spm=1018.2226.3001.4187)
  
  - | 异常类型          | 含义                                                         |
    | ----------------- | ------------------------------------------------------------ |
    | AssertionError    | 当 assert 关键字后的条件为假时，程序运行会停止并抛出 AssertionError 异常 |
    | AttributeError    | 当试图访问的对象属性不存在时抛出的异常                       |
    | IndexError        | 索引超出序列范围会引发此异常                                 |
    | KeyError          | 字典中查找一个不存在的关键字时引发此异常                     |
    | NameError         | 尝试访问一个未声明的变量时，引发此异常                       |
    | TypeError         | 不同类型数据之间的无效操作                                   |
    | ZeroDivisionError | 除法运算中除数为 0 引发此异常                                |
  

# 二、异常处理语法

## 2.1 语法结构

- ```python
  try:
      可能产生异常的代码块
  except [ (Error1, Error2, ... ) [as e] ]:
      处理异常的代码块1
  except [ (Error3, Error4, ... ) [as e] ]:
      处理异常的代码块2
  except  [Exception]:
      处理其它异常
  ```

  - Error表示具体异常类型，**一个except可以处理多个异常类型**
  - as e作为可选参数，给程序起一个别名
  - e**xception可选参数，指代处理所有的异常类型**

## 2.2 try except 语句的执行流程如下：

- 首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常
- 当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。**如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。如果找到了，就继续处理该模块里面的代码程序逻辑。执行完except代码之后，会继续从进入except之处执行后续的代码**

## 2.3 获取特定的异常有关信息

- 个 except 可以同时处理多个异常，那么我们如何知道当前处理的到底是哪种异常呢？

  - 种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：
    - args：返回异常的错误编号和描述字符串
    - str(e)：返回异常信息，但不包括异常信息的类型
    - repr(e)：返回较全的异常信息，包括异常信息的类型

  ```python
  try:
      1/0
  except Exception as e:
      # 访问异常的错误编号和详细信息
      print(e.args)
      print(str(e))
      print(repr(e))
  
  # ('division by zero',)
  # division by zero
  # ZeroDivisionError('division by zero',)
  ```

# 三、try except else

- 通常捕获到异常之后，执行完except之中的内容就会继续执行后续的内容。添加else的作用是，如果捕获了异常else中的语句不会执行，如果没有异常，照常执行try。**也就是说，发生异常时else会出现，普通情况下else不会出现**

- else 必须搭配`try except` 使用

  ```python
  try:
      result = 10 / int(input('enter number:'))
       finally 语句，通常用来为 try 块中的程序做扫尾清理工作print(result)
  
  except Exception:
      print("error!!!")
  else:
      print("not error!!!")
  
  
  #--发生异常，不执行else里面的语句
  enter number:0
  error!!!
  #--不发生异常，执行else里面的语句
  enter number:10
  1.0
  not error!!!
  ```

# 四、try except finally

- 语法规则

  -  finally 语句，通常用来为 try 块中的程序做扫尾清理工作

  - 和 else 语句不同，finally 只要求和 try 搭配使用

  - 在整个异常处理机制中，finally 语句的功能是：无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块
  - 当 try 块中代码发生异常，导致程序崩溃时，在崩溃前 Python 解释器也会执行 finally 块中的代码。**也就是说，finally模块里面的代码是一定会执行的**

- 应用场景

  - 在某些情况下，当 try 块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就放在 finally 块中

  - Python 垃圾回收机制，只能帮我们回收变量、类对象占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作

    ```python
    try:
        result = 10 / int(input('enter number:'))
        print(result)
    
    except Exception:
        print("error!!!")
    else:
        print("not error!!!")
    
    finally:
        print("here!!")
    
    # --可以看到无论是否发生了异常finally语句都会执行
    0.8333333333333334
    not error!!!
    here!!
    
    enter number:0
    error!!!
    here!!
    ```

# 五、手动抛出异常raise

- 基本语法：`raise [exceptionName [(reason)]]`
  - 用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述
  - 如果可选参数全部省略，则 raise 会把当前错误原样抛出
  - 如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息

- 三种用法

  - raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。

  - raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。

  - raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。      

    ```python
    try:
        a = input("输入一个数：")
        # 判断用户输入的是否为数字
        if (not a.isdigit()):
            raise ValueError("a 必须是数字") # 在try中抛出异常，因此被except捕获
    except ValueError as e:
        print("引发异常：", repr(e))
    
    # 输入一个数：d
    # 引发异常： ValueError('a 必须是数字',)
    
    
    #---------raise不带参数-----——#
    try:
        a = input("输入一个数：")
        # 判断用户输入的是否为数字
        if (not a.isdigit()):
            raise ValueError("a 必须是数字")
    except ValueError as e:
        print("引发异常：", repr(e))
        raise # 再次抛出
    
    # 输入一个数：d
    # 引发异常： ValueError('a 必须是数字',)
    # Traceback (most recent call last):
    #   File "/Users/didi/PycharmProjects/pythonProject/main.py", line 5, in <module>
    #     raise ValueError("a 必须是数字")
    # ValueError: a 必须是数字
    
    #-----在没有引发过异常的程序使用无参的 raise 语句时--------
    #默认引发的是 RuntimeError 异常
    try:
        a = input("输入一个数：")
        if(not a.isdigit()):
            raise
    except RuntimeError as e:
        print("引发异常：",repr(e))
    
    # 输入一个数：d
    # 引发异常： RuntimeError('No active exception to reraise',)
    
    ```

# 六、获取详细异常信息

## 6.1 概述

- 实际调试程序的过程中，有时只获得异常的类型是远远不够的，还需要借助更详细的异常信息才能解决问题。捕获异常时，有 2 种方式可获得更多的异常信息，分别是：
  - 使用 sys 模块中的 exc_info 方法；
  - 使用 traceback 模块中的相关函数

    ```python
    # 目的：
    # 1、验证异常类的创建
    # 2、异常的定位使用
    
    import traceback
    
    
    class test_except(Exception):
      pass
    
    
    
    num = 100
    
    try:
      if num:
        print('即将抛出异常')
        print(traceback.format_exc())
        raise test_except("test error!!")
    
    except Exception as error:
      print(error)
      traceback.print_exc()
    
    ```
  
- 模块 sys 中，有两个方法可以返回异常的全部信息，分别是 exc_info() 和 last_traceback()

## 6.2 exc_info()

- exc_info() 方法会将当前的异常信息以元组的形式返回，该元组中包含 3 个元素，分别为 type、value 和 traceback，它们的含义分别是：

  - type：异常类型的名称，它是 BaseException 的子类

  - value：捕获到的异常实例。

  - traceback：是一个 traceback 对象

    ```python
    import sys
    import traceback
    
    try:
        10 / 0
    except Exception:
        # print(sys.exc_info())
        traceback.print_tb(sys.exc_info()[2])
    
    # ------sys.exc_info()输出
    
    # (<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero',), <traceback object at 0x7f863371a908>)
    # 该异常信息是一个元组
    # 第一个元素是一个 ZeroDivisionError 类
    # 第 2 个元素是异常类型 ZeroDivisionError 类的一个实例
    # 第 3 个元素为一个 traceback 对象
    # 要查看 traceback 对象包含的内容，需要先引进 traceback 模块，然后调用 traceback 模块中的 print_tb 方法，
    # 并将 sys.exc_info() 输出的 traceback 对象作为参数参入
    
    # -------traceback.print_tb输出
    # File "/Users/didi/PycharmProjects/pythonProject/main.py", line 5, in <module>
    # 10 / 0
    ```

## 6.3 traceback

- [参考链接](https://blog.csdn.net/yuanfate/article/details/119916008?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165845667216782391888941%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165845667216782391888941&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119916008-null-null.142^v33^new_blog_pos_by_title,185^v2^control&utm_term=traceback&spm=1018.2226.3001.4187)

- sys.exc_info() 方法获取更多的异常信息。traceback 模块，**可以用来查看异常的传播轨迹，追踪异常触发的源头**

- 使用 traceback 模块查看异常传播轨迹，首先需要将 traceback 模块引入，该模块提供了如下两个常用方法：

  - traceback.print_exc()：将异常传播轨迹信息输出到控制台或指定文件中

  - format_exc()：将异常传播轨迹信息转换成字符串

    ```python
    import traceback
    
    
    class SelfException(Exception):
        pass
    
    
    def main():
        firstfunc()
    
    
    def firstfunc():
        secondfunc()
    
    
    def secondfunc():
        raise SelfException("自定义异常信息")
    
    
    try:
        main()
    except:
        # 捕捉异常，并将异常传播信息输出控制台
        traceback.print_exc()
        # 捕捉异常，并将异常传播信息输出指定文件中
        traceback.print_exc(file=open('log.txt', 'a'))
    
    # Traceback (most recent call last):
    #   File "/Users/didi/PycharmProjects/pythonProject/main.py", line 21, in <module>
    #     main()
    #   File "/Users/didi/PycharmProjects/pythonProject/main.py", line 9, in main
    #     firstfunc()
    #   File "/Users/didi/PycharmProjects/pythonProject/main.py", line 13, in firstfunc
    #     secondfunc()
    #   File "/Users/didi/PycharmProjects/pythonProject/main.py", line 17, in secondfunc
    #     raise SelfException("自定义异常信息")
    # SelfException: 自定义异常信息
    ```

    

# 七、 logging模块用法

## 7.1 概念

- 在 Python 中，有一种比频繁使用 print() 调试程序更简便的方法，就是使用 logging 模块，该模块可以很**容易地创建自定义的消息记录，这些日志消息将描述程序执行何时到达日志函数调用，并列出指定的任何变量当时的值**

## 7.2 使用

- 启用 logging 模块很简单，直接将下面的代码复制到程序开头

  ```python
  import logging
  
  logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')
  logging.debug('Start of program')
  def factor(n):
      logging.debug('Start of factorial(%d)',n)
      if n < 3:
          return n
      else:
          return n * factor(n - 1)
  
  print(factor(6))
  
  #------通过调用logging.debuug输出信息-----------
  720
   2022-03-08 11:01:57,991 - DEBUG - Start of program
   2022-03-08 11:01:57,991 - DEBUG - Start of factorial(6)
   2022-03-08 11:01:57,991 - DEBUG - Start of factorial(5)
   2022-03-08 11:01:57,991 - DEBUG - Start of factorial(4)
   2022-03-08 11:01:57,991 - DEBUG - Start of factorial(3)
   2022-03-08 11:01:57,991 - DEBUG - Start of factorial(2)
  ```

  

## 7.3 日志级别日志的级别

- “日志级别”提供了一种方式，按重要性对日志消息进行分类。5 个日志级别如下表所示，从最不重要到最重要。利用不同的日志函数，消息可以按某个级别记入日志

- | 级别     | 对应的函数         | 描述                                                         |
  | -------- | ------------------ | ------------------------------------------------------------ |
  | DEBUG    | logging.debug()    | 最低级别，用于小细节，通常只有在诊断问题时，才会关心这些消息。 |
  | INFO     | logging.info()     | 用于记录程序中一般事件的信息，或确认一切工作正常。           |
  | WARNING  | logging.warning()  | 用于表示可能的问题，它不会阻止程序的工作，但将来可能会。     |
  | ERROR    | logging.error()    | 用于记录错误，它导致程序做某事失败。                         |
  | CRITICAL | logging.critical() | 最高级别，用于表示致命的错误，它导致或将要导致程序完全停止工作。 |

- 日志级别的好处在于，我们可以改变想看到的日志消息的优先级。比如说，向 basicConfig() 函数传入 logging.DEBUG 作为 level 关键字参数，这将显示所有级别为 DEBUG 的日志消息，其余的同理，小于设置级别的都会被跳过

- 日志禁用

  - 在调试完程序后，可能并不希望所有这些日志消息出现在屏幕上，这时就可以使用 logging.disable() 函数禁用这些日志消息，从而不必进入到程序中，手工删除所有的日志调用
  - logging.disable() 函数的用法是，向其传入一个日志级别，它会禁止该级别以及更低级别的所有日志消息。因此，如果想要禁用所有日志，只要在程序中添加 logging.disable(logging.CRITICAL) 即可

- 将日志输入到文件之中            

  - 将日志消息输出到文件中的实现方法很简单，只需要设置 logging.basicConfig() 函数中的 filename 关键字参数即可

    ```python
    >>> import logging
    >>> logging.basicConfig(filename='demo.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
    
    # 此程序中，将日志消息存储到了 demo.txt 文件中，该文件就位于运行的程序文件所在的目录
    ```

    