# 一、问题

- 个应用负载均衡 部署在两台服务器上，如果刚好凑钱两台服务器操作同一条数据，这类的并发要怎么解决？
  - 这中案例属于浓缩版的分布式系统。可以通过分布式锁来解决

# 二、问题记录

- 对于同一条数据进行操作，导致数据被覆盖![image-20230520004220545](https://yrecord.oss-cn-hangzhou.aliyuncs.com/picture/202305200042370.png)
  - 解决办法
    - 状态机，如果是有人进入页面对数据操作则进行标识。但是可能一开始两人都没有标识进入这个页面
    - 对于临界进行加锁处理。如果是分布式情况下怎么办？
      - 使用分布式锁
- 分布式程序中防止多用户对同一数据更新的问题
  - 我们可以对表加一个时间的字段，每次更新进行判断，当前提交的数据中的改时间值是否和表中的该字段的值相同，如果相同就进行更新操作。在更新的同时也把这个时间字段设置成最新的
- 数据库并发操作与数据的不一致
  - [参考链接](https://blog.csdn.net/weixin_30426879/article/details/95506052?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-95506052-blog-47211025.235%5Ev36%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-95506052-blog-47211025.235%5Ev36%5Epc_relevant_default_base3&utm_relevant_index=6)

- 集群更新同一条数据的问题(使用了负载均衡后，之前在同步锁里面的代码块要怎么处理)
  - [参考链接](https://blog.csdn.net/zhanglei082319/article/details/88027484?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168452126016800215040370%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=168452126016800215040370&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-88027484-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%90%8C%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7&spm=1018.2226.3001.4187)
- 丢失更新
  - 看书
  

# 三、其它记录

- Mysql 自增长键天然就是加锁的
- 集群不是分布式
  - 集群： 同样的业务，分布在多台电脑之中，使用的是同一个数据库，并且做了负载均衡
  - 分布式： 将一个业务拆分成多个子模块，分布在不同的业务之中

```
多个客户端连接同一套数据，怎样防止同时更新

点击复制后，将打开C知道体验页

有几种方法可以防止多个客户端同时更新同一份数据：

使用锁机制：在更新数据时，先对数据进行加锁，防止其他客户端同时进行更新。当一个客户端完	成更新后，再释放锁，其他客户端才能进行更新。但是，这种方法可能会导致性能问题，因为其他客户端需要等待锁的释放才能进行更新。

使用事务：在更新数据时，使用事务来保证数据的一致性。事务可以保证如果有一个客户端正在更新数据，其他客户端无法进行更新。但是，这种方法也可能会影响性能，因为事务需要一定的时间来完成。

使用乐观锁：在更新数据时，每个客户端都会获取数据的版本号，当客户端更新数据时，先检查版本号是否发生变化，如果数据已经被其他客户端更新，则客户端无法进行更新。这种方法可以避免锁的性能问题，但需要对数据进行版本控制。

无论使用哪种方法，都需要对数据进行合理的设计和管理，以确保数据的一致性。

点击复制后，将打开C知道体验页
|

python Django web开发比较好的书籍推荐

点击复制后，将打开C知道体验页

以下是一些比较好的Django web开发书籍推荐：

《Django企业开发实战》：该书对Django的开发流程和技术细节进行了详细的讲解，并提供了大量的示例代码和实际开发经验，适合已经具备一定Python编程基础和Web开发基础的读者。

《Django官方文档》：Django官方文档详细地介绍了Django框架的各个方面，包括模型、视图、模板、表单、认证等，是学习Django的必备参考资料。

《Django编程基础》：该书从Django的基本概念开始，逐步深入介绍了Django框架的各个方面，包括模型、视图、模板、表单、中间件、缓存等，适合初学者阅读。

《Django开发实战》：该书以实战为主线，通过实现一个完整的Django项目，演示了Django在实际开发中的应用，同时也介绍了一些常用的第三方库和工具，适合已经具备一定Python编程和Web开发经验的读者。

以上都是比较好的Django web开发书籍，可以根据自己的实际情况选择适合自己的书籍进行学习。
```

- [Mysql 乐观/悲观锁](https://blog.csdn.net/z_ssyy/article/details/128565101?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168458067916800215097592%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168458067916800215097592&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-128565101-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=mysql%20%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81&spm=1018.2226.3001.4187)

- [python基于redis实现分布式锁](https://blog.csdn.net/weixin_30872499/article/details/102313842?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168458091716800184123500%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168458091716800184123500&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-102313842-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=python%20%E5%AE%9E%E7%8E%B0redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&spm=1018.2226.3001.4187)
- 保证缓存与数据库双写时的数据一致性，可以采取以下措施：
  1. 使用缓存更新数据库时，需要保证缓存和数据库的操作是原子性的，即要么同时成功，要么同时失败。
  2. 在更新数据库时，先更新数据库，再更新缓存，这样可以保证缓存中的数据与数据库中的数据一致。
  3. 在更新缓存时，可以使用分布式锁来保证同一时间只有一个线程可以更新缓存，避免并发更新导致数据不一致。
  4. 定期清理缓存中的过期数据，避免缓存中的数据与数据库中的数据不一致。
  5. 在缓存和数据库之间设置数据同步机制，当缓存中的数据发生变化时，自动同步到数据库中，保证数据的一致性
  6. [场景分析](https://blog.csdn.net/weixin_44421461/article/details/123343423?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168467805516800180674567%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=168467805516800180674567&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-123343423-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E5%89%8D%E5%90%8E%E8%AF%BB%E5%8F%96%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98&spm=1018.2226.3001.4187)
  7. [Django中的缓存介绍](https://github.com/jazzband/django-redis/issues/380)